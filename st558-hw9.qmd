---
title: "ST-558 Homework 9"
format: html
---
# Load libraries
```{r setup, include=FALSE}
#suppressPackageStartupMessages(library(tidyverse))
lapply(c("ggplot2", "dplyr", "tidyr", "readr", "purrr", "tibble", "forcats"), library, character.only = TRUE)
suppressPackageStartupMessages(library(tidymodels))
```

# Read in Data
```{r}
bike_data <- read_csv("https://www4.stat.ncsu.edu/~online/datasets/SeoulBikeData.csv",
                      locale = locale(encoding = "latin1"))
```

## Convert `Date` into a date format
## Recode `Seasons`, `Holiday`, and `Functioning Day` as factors
```{r}
bike_data <- bike_data |> mutate(Date = lubridate::dmy(Date),
                                 Seasons = factor(Seasons),
                                 Holiday = factor(Holiday),
                                 `Functioning Day` = factor(`Functioning Day`))
```

## Rename variables
```{r}
bike_data <- bike_data |> rename(date = Date,
                    bike_count = `Rented Bike Count`,
                    hour = Hour,
                    temp = `Temperature(°C)`,
                    humidity = `Humidity(%)`, 
                    wind_speed = `Wind speed (m/s)`,
                    visibility = `Visibility (10m)`,
                    dew_point = `Dew point temperature(°C)`,
                    solar_rad = `Solar Radiation (MJ/m2)`,
                    rainfall = `Rainfall(mm)`,
                    snowfall = `Snowfall (cm)`,
                    season = Seasons,
                    holiday = Holiday,
                    func_day = `Functioning Day`)
```

## Transform Data
Note, the variable `Functioning Day` also renamed `func_day` is dropped in the grouping.
Also, rainfall and snowfall means were not calculated with the rest of the mean weather variables.
```{r}
bikes <- bike_data |>
    filter(func_day == "Yes") |>
    select(-func_day) |>
    group_by(date, season, holiday) |> 
    summarize(bike_count = sum(bike_count, na.rm = TRUE),
              rainfall   = sum(rainfall, na.rm = TRUE),
              snowfall   = sum(snowfall, na.rm = TRUE),
              across(c(temp, humidity, wind_speed, visibility, dew_point, solar_rad),
                     ~ mean(.x, na.rm = TRUE), .names = "{.col}"),
              .groups = "drop",) 
bikes
```

# Split Data
```{r}
set.seed(1)
bike_split <- initial_split(bikes, prop = 0.75, strata = season)
bike_train <- training(bike_split)
bike_test <- testing(bike_split)
bike_10_fold <- vfold_cv(bike_train, 10)
```

# Fitting MLR Models
## First Linear Model and Recipe
Model uses all variables to predict `bike_count`.
```{r}
mlr_recipe1 <-
    recipe(bike_count ~ ., data = bike_train) |>
    update_role(date, new_role = "ID") |>
    step_date(date, features = c("dow")) |>
    step_mutate(day_type = factor(
        if_else(date_dow %in% c("Sat", "Sun"), "weekend", "weekday"),
        levels = c("weekday", "weekend"))
    ) |>
    step_rm(date_dow) |>
    step_normalize(all_numeric_predictors()) |>
    step_dummy(season, holiday, day_type)
```

## Second Linear Model and Recipe
Adding interaction terms between `season:holiday`, `season:temp`, and `temp:rainfall` to model 1.
```{r}
mlr_recipe2 <-
    mlr_recipe1 |>
    step_interact(terms = ~ starts_with("season")*starts_with("holiday") +
                      starts_with("season")*temp +
                      temp*rainfall)
```

## Third Linear Model and Recipe
Added quadratic terms to all numeric variables from model 2.
```{r}
mlr_recipe3 <- 
    mlr_recipe2 |>
    step_poly(rainfall, snowfall, temp, humidity, wind_speed, visibility, dew_point, solar_rad, 
              degree = 2)
```

## Set up linear regression engine, workflow, and fit models using 10-fold CV split
```{r}
linear_spec <- linear_reg() |> set_engine("lm")
mlr_fit1 <- workflow() |> add_recipe(mlr_recipe1) |> add_model(linear_spec) |> fit_resamples(bike_10_fold)
mlr_fit2 <- workflow() |> add_recipe(mlr_recipe2) |> add_model(linear_spec) |> fit_resamples(bike_10_fold)
mlr_fit3 <- workflow() |> add_recipe(mlr_recipe3) |> add_model(linear_spec) |> fit_resamples(bike_10_fold)
```

## Training Performance Metrics
```{r}
rbind(
    mlr_fit1 |> collect_metrics(),
    mlr_fit2 |> collect_metrics(),
    mlr_fit3 |> collect_metrics())
```

## Select Linear Best Model to Predict Test Data and Final Output
```{r}
final_fit <- workflow() |> add_recipe(mlr_recipe3) |> add_model(linear_spec) |> last_fit(bike_split)
final_fit |> collect_metrics()
```

```{r}
final_fit |> extract_fit_parsnip() |> tidy()
```

# LASSO Model
```{r}
lasso_recipe <- linear_recipe1
lasso_spec <- linear_reg(penalty = tune(), mixture = 1) |> set_engine("glmnet")
lasso_workflow <- workflow() |> add_recipe(lasso_recipe) |> add_model(lasso_spec)
lasso_grid <- lasso_workflow |> tune_grid(resamples = bike_10_fold,
                                          grid = grid_regular(penalty(), levels = 200)) 
```

